{"body": "<div class=\"section\" id=\"http-client-apis\">\n<span id=\"id1\"></span><h1>HTTP Client APIs</h1>\n<p>Apart from the server-side HTTP abstractions <em>spray-can</em> also contains a client-side HTTP implementation that enables\nyour application to interact with other HTTP servers. And just like on the server side it is actor-based,\nfully asynchronous, low-overhead and built on top of <a class=\"reference external\" href=\"http://doc.akka.io/docs/akka/2.2.0-RC1/scala/io.html\">Akka IO</a> / <a class=\"reference internal\" href=\"../../spray-io/#spray-io\"><em>spray-io</em></a>.</p>\n<p>As the counterpart of the <a class=\"reference internal\" href=\"../http-server/#http-server\"><em>HTTP Server</em></a> it shares all core features as well as the basic &#8220;low-level&#8221; philosophy\nwith the server-side constructs.</p>\n<p>The <em>spray-can</em> client API offers three different levels of abstraction that you can work with\n(from lowest to highest level):</p>\n<div class=\"toctree-wrapper compound\">\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"connection-level/\">Connection-level API</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"host-level/\">Host-level API</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"request-level/\">Request-level API</a></li>\n</ul>\n</div>\n<div class=\"section\" id=\"basic-api-structure\">\n<h2>Basic API Structure</h2>\n<p>Depending on the specific needs of your use case you should pick the</p>\n<dl class=\"docutils\">\n<dt><a class=\"reference internal\" href=\"connection-level/#connectionlevelapi\"><em>Connection-level API</em></a></dt>\n<dd>for full-control over when HTTP connections are opened/closed and how requests are scheduled across them.</dd>\n<dt><a class=\"reference internal\" href=\"host-level/#hostlevelapi\"><em>Host-level API</em></a></dt>\n<dd>for letting <em>spray-can</em> manage a connection-pool for <em>one specific</em> host.</dd>\n<dt><a class=\"reference internal\" href=\"request-level/#requestlevelapi\"><em>Request-level API</em></a></dt>\n<dd>for letting <em>spray-can</em> take over all connection management.</dd>\n</dl>\n<p>You can interact with <em>spray-can</em> on different levels at the same time and, independently of which API level you choose,\n<em>spray-can</em> will happily handle many thousand concurrent connections to a single or many different hosts.</p>\n</div>\n<div class=\"section\" id=\"chunked-requests\">\n<h2>Chunked Requests</h2>\n<p>While the host- and request-level APIs do not currently support chunked (streaming) HTTP requests the connection-level\nAPI does. Alternatively to a single <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> the application can choose to send this sequence of individual\nmessages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedRequestStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The connection actor will render these as one logical HTTP request with <tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding:</span> <span class=\"pre\">chunked</span></tt>.\nThe timer for checking request timeouts (if configured to non-zero) only starts running when the final\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt> message was sent out.</p>\n</div>\n<div class=\"section\" id=\"chunked-responses\">\n<h2>Chunked Responses</h2>\n<p>Chunked (streaming) responses are supported by all three API levels. If the <tt class=\"docutils literal\"><span class=\"pre\">response-chunk-aggregation-limit</span></tt>\nconnection config setting is set to zero the individual response parts of chunked requests are dispatched to the\napplication as they come in. In these cases a full response consists of the following messages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The timer for checking request timeouts (if configured to non-zero) will stop running as soon as the initial\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt> message has been received, i.e. there is currently no timeout checking\nfor and in between individual response chunks.</p>\n</div>\n<div class=\"section\" id=\"http-headers\">\n<h2>HTTP Headers</h2>\n<p>When a <em>spray-can</em> connection actor receives an HTTP response it tries to parse all its headers into their respective\n<em>spray-http</em> model classes. No matter whether this succeeds or not, the connection actor will always pass on all\nreceived headers to the application. Unknown headers as well as ones with invalid syntax (according to <em>spray</em>&#8216;s header\nparser) will be made available as <tt class=\"docutils literal\"><span class=\"pre\">RawHeader</span></tt> instances. For the ones exhibiting parsing errors a warning message is\nlogged depending on the value of the <tt class=\"docutils literal\"><span class=\"pre\">illegal-header-warnings</span></tt> config setting.</p>\n<p>The following message headers are managed by the <em>spray-can</em> layer itself and as such are <strong>ignored</strong> if you &#8220;manually&#8221;\nadd them to an outgoing request:</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding</span></tt></li>\n</ul>\n<p>There are two exceptions for requests in <tt class=\"docutils literal\"><span class=\"pre\">ChunkedRequestStart</span></tt> messages:</p>\n<ol class=\"arabic simple\">\n<li>They are allowed to contain a user-specified <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header if their entity is empty.</li>\n<li>They <em>must</em> contain a user-specified <tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt> header if <tt class=\"docutils literal\"><span class=\"pre\">spray.can.client.chunkless-streaming</span></tt> is enabled.\nThis <tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt> header <em>must</em> fit the total length of all requests chunks.</li>\n</ol>\n<p>Additionally <em>spray-can</em> will render a</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Host</span></tt> request header if none is explicitly added.</li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">User-Agent</span></tt> default request header if none is explicitly defined. The default value can be configured with the\n<tt class=\"docutils literal\"><span class=\"pre\">spray.can.client.user-agent-header</span></tt> configuration setting.</li>\n</ul>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header has special status in <em>spray</em> since its value is part of the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt> model\nclass. Even though the header also remains in the <tt class=\"docutils literal\"><span class=\"pre\">headers</span></tt> list of the <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> <em>sprays</em> higher layers\n(like <em>spray-client</em>) only work with the <tt class=\"docutils literal\"><span class=\"pre\">ContentType</span></tt> value contained in the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"ssl-support\">\n<h2>SSL Support</h2>\n<p>SSL support is enabled</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li>for the connection-level API by setting <tt class=\"docutils literal\"><span class=\"pre\">Http.Connect(sslEncryption</span> <span class=\"pre\">=</span> <span class=\"pre\">true)</span></tt> when connecting to a server</li>\n<li>for the host-level API by setting <tt class=\"docutils literal\"><span class=\"pre\">Http.HostConnectorSetup(sslEncryption</span> <span class=\"pre\">=</span> <span class=\"pre\">true)</span></tt> when creating a host connector</li>\n<li>for the request-level API by using an <tt class=\"docutils literal\"><span class=\"pre\">https</span></tt> URL in the request</li>\n</ul>\n</div></blockquote>\n<p>Particular SSL settings can be configured via the implicit\n<tt class=\"docutils literal\"><span class=\"pre\">ClientSSLEngineProvider</span></tt> member on the <tt class=\"docutils literal\"><span class=\"pre\">Http.Connect</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">Http.HostConnectorSetup</span></tt> command messages.\nAn <tt class=\"docutils literal\"><span class=\"pre\">ClientSSLEngineProvider</span></tt> is essentially a function <tt class=\"docutils literal\"><span class=\"pre\">PipelineContext</span> <span class=\"pre\">\u21d2</span> <span class=\"pre\">Option[SSLEngine]</span></tt> which determines\nwhether encryption is to be performed and, if so, which <tt class=\"docutils literal\"><span class=\"pre\">javax.net.ssl.SSLEngine</span></tt> instance is to be used. By returning\n<tt class=\"docutils literal\"><span class=\"pre\">None</span></tt> the <tt class=\"docutils literal\"><span class=\"pre\">ClientSSLEngineProvider</span></tt> can decide to disable SSL support even if SSL support was requested by the means\ndescribed above.</p>\n<p>If you&#8217;d like to apply some custom configuration to your <tt class=\"docutils literal\"><span class=\"pre\">SSLEngine</span></tt> instances an easy way would be to bring a custom\nengine provider into scope, e.g. like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">spray.io.ClientSSLEngineProvider</span>\n\n<span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">myEngineProvider</span> <span class=\"k\">=</span> <span class=\"nc\">ClientSSLEngineProvider</span> <span class=\"o\">{</span> <span class=\"n\">engine</span> <span class=\"k\">=&gt;</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledCipherSuites</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledProtocols</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;SSLv3&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;TLSv1&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>EngineProvider creation also relies on an implicitly available <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt>, which is defined like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">trait</span> <span class=\"nc\">SSLContextProvider</span> <span class=\"k\">extends</span> <span class=\"o\">(</span><span class=\"nc\">PipelineContext</span> <span class=\"k\">\u21d2</span> <span class=\"nc\">Option</span><span class=\"o\">[</span><span class=\"kt\">SSLContext</span><span class=\"o\">])</span>\n</pre></div>\n</div>\n<p>The default <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt> simply provides an implicitly available &#8220;constant&#8221; <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>, by default the\n<tt class=\"docutils literal\"><span class=\"pre\">SSLContext.getDefault</span></tt> is used. This means that the easiest way to have the server use a custom <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>\nis to simply bring one into scope implicitly:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">javax.net.ssl.SSLContext</span>\n\n<span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">mySSLContext</span><span class=\"k\">:</span> <span class=\"kt\">SSLContext</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">context</span> <span class=\"k\">=</span> <span class=\"nc\">SSLContext</span><span class=\"o\">.</span><span class=\"n\">getInstance</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS&quot;</span><span class=\"o\">)</span>\n  <span class=\"c1\">// context.init(...)</span>\n  <span class=\"n\">context</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"redirection-following\">\n<h2>Redirection Following</h2>\n<p>Automatic redirection following for <tt class=\"docutils literal\"><span class=\"pre\">3xx</span></tt> responses is supported by setting configuring the\n<tt class=\"docutils literal\"><span class=\"pre\">spray.can.host-connector.max-redirects</span></tt> setting. This is the logic that is then applied:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li>If set to zero redirection responses will not be followed, i.e. they&#8217;ll be returned to the user as is.</li>\n<li>If set to a value &gt; zero redirection responses will be followed up to the given number of times.</li>\n<li>If the redirection chain is longer than the configured value the first redirection response that is\nis not followed anymore is returned to the user as is.</li>\n</ul>\n</div></blockquote>\n<p>By default <tt class=\"docutils literal\"><span class=\"pre\">max-redirects</span></tt> is set to 0.</p>\n<p>Since this setting is at the host level, it is possible to configure a different number of <tt class=\"docutils literal\"><span class=\"pre\">max-redirects</span></tt> for\ndifferent hosts (see <a class=\"reference internal\" href=\"request-level/#requestlevelapi\"><em>Request-level API</em></a>). In this situation the <tt class=\"docutils literal\"><span class=\"pre\">max-redirects</span></tt> configured for the host of the\ninitial request is respected for the entire redirection chain. This is true even if redirection means changing to another\nhost.</p>\n<div class=\"section\" id=\"which-redirects-are-followed\">\n<h3>Which redirects are followed?</h3>\n<p>This table shows which http method is used to follow redirects for given request methods and response status codes. Any\nrequest method and response status code combination not in the table will not result in redirection following and the\nresponse will be returned as is.</p>\n<table border=\"1\" class=\"table table-striped docutils\">\n<colgroup>\n<col width=\"27%\" />\n<col width=\"26%\" />\n<col width=\"29%\" />\n<col width=\"19%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Request Method</th>\n<th class=\"head\">Response Status Code</th>\n<th class=\"head\">Redirection Method</th>\n<th class=\"head\">Specification</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td>GET / HEAD</td>\n<td>301 / 302 / 303</td>\n<td>Original request method</td>\n<td><a class=\"reference external\" href=\"http://tools.ietf.org/html/rfc2616#section-10.3\">RFC 2616</a></td>\n</tr>\n<tr class=\"row-odd\"><td>Any (except GET / HEAD)</td>\n<td>302 / 303</td>\n<td>GET</td>\n<td><a class=\"reference external\" href=\"http://tools.ietf.org/html/rfc2616#section-10.3\">RFC 2616</a></td>\n</tr>\n<tr class=\"row-even\"><td>Any</td>\n<td>307</td>\n<td>Original request method</td>\n<td><a class=\"reference external\" href=\"https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-25#section-6.4.7\">HttpBis Draft</a></td>\n</tr>\n<tr class=\"row-odd\"><td>Any</td>\n<td>308</td>\n<td>Original request method</td>\n<td><a class=\"reference external\" href=\"http://tools.ietf.org/html/draft-reschke-http-status-308-07#section-3\">308 Draft</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "HTTP Client APIs", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-can/http-client/index", "next": {"link": "connection-level/", "title": "Connection-level API"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-can/http-client/connection-level", "Connection-level API", "N", "next"], ["documentation/spray-can/http-server", "HTTP Server", "P", "previous"]], "meta": {}, "parents": [{"link": "../../", "title": "Documentation"}, {"link": "../", "title": "spray-can"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">HTTP Client APIs</a><ul>\n<li><a class=\"reference internal\" href=\"#basic-api-structure\">Basic API Structure</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-requests\">Chunked Requests</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-responses\">Chunked Responses</a></li>\n<li><a class=\"reference internal\" href=\"#http-headers\">HTTP Headers</a></li>\n<li><a class=\"reference internal\" href=\"#ssl-support\">SSL Support</a></li>\n<li><a class=\"reference internal\" href=\"#redirection-following\">Redirection Following</a><ul>\n<li><a class=\"reference internal\" href=\"#which-redirects-are-followed\">Which redirects are followed?</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../http-server/", "title": "HTTP Server"}, "metatags": ""}