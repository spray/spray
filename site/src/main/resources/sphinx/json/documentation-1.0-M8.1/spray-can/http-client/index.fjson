{"body": "<div class=\"section\" id=\"http-client-apis\">\n<span id=\"id1\"></span><h1>HTTP Client APIs</h1>\n<p>Apart from the server-side HTTP abstractions <em>spray-can</em> also contains a client-side HTTP implementation that enables\nyour application to interact with other HTTP servers. And just like on the server side it is actor-based,\nfully asynchronous, low-overhead and built on top of <a class=\"reference external\" href=\"http://doc.akka.io/docs/akka/2.2.0-RC1/scala/io.html\">Akka IO</a> / <a class=\"reference internal\" href=\"../../spray-io/#spray-io\"><em>spray-io</em></a>.</p>\n<p>As the counterpart of the <a class=\"reference internal\" href=\"../http-server/#http-server\"><em>HTTP Server</em></a> it shares all core features as well as the basic &#8220;low-level&#8221; philosophy\nwith the server-side constructs.</p>\n<p>The <em>spray-can</em> client API offers three different levels of abstraction that you can work with\n(from lowest to highest level):</p>\n<div class=\"toctree-wrapper compound\">\n<ul>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"connection-level/\">Connection-level API</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"host-level/\">Host-level API</a></li>\n<li class=\"toctree-l1\"><a class=\"reference internal\" href=\"request-level/\">Request-level API</a></li>\n</ul>\n</div>\n<div class=\"section\" id=\"basic-api-structure\">\n<h2>Basic API Structure</h2>\n<p>Depending on the specific needs of your use case you should pick the</p>\n<dl class=\"docutils\">\n<dt><a class=\"reference internal\" href=\"connection-level/#connectionlevelapi\"><em>Connection-level API</em></a></dt>\n<dd>for full-control over when HTTP connections are opened/closed and how requests are scheduled across them.</dd>\n<dt><a class=\"reference internal\" href=\"host-level/#hostlevelapi\"><em>Host-level API</em></a></dt>\n<dd>for letting <em>spray-can</em> manage a connection-pool for <em>one specific</em> host.</dd>\n<dt><a class=\"reference internal\" href=\"request-level/#requestlevelapi\"><em>Request-level API</em></a></dt>\n<dd>for letting <em>spray-can</em> take over all connection management.</dd>\n</dl>\n<p>You can interact with <em>spray-can</em> on different levels at the same time and, independently of which API level you choose,\n<em>spray-can</em> will happily handle many thousand concurrent connections to a single or many different hosts.</p>\n</div>\n<div class=\"section\" id=\"chunked-requests\">\n<h2>Chunked Requests</h2>\n<p>While the host- and request-level APIs do not currently support chunked (streaming) HTTP requests the connection-level\nAPI does. Alternatively to a single <tt class=\"docutils literal\"><span class=\"pre\">HttpRequest</span></tt> the application can choose to send this sequence of individual\nmessages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedRequestStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The connection actor will render these as one logical HTTP request with <tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding:</span> <span class=\"pre\">chunked</span></tt>.\nThe timer for checking request timeouts (if configured to non-zero) only starts running when the final\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt> message was sent out.</p>\n</div>\n<div class=\"section\" id=\"chunked-responses\">\n<h2>Chunked Responses</h2>\n<p>Chunked (streaming) responses are supported by all three API levels. If the <tt class=\"docutils literal\"><span class=\"pre\">response-chunk-aggregation-limit</span></tt>\nconnection config setting is set to zero the individual response parts of chunked requests are dispatched to the\napplication as they come in. In these cases a full response consists of the following messages:</p>\n<ul class=\"simple\">\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt></li>\n<li>Zero or more <tt class=\"docutils literal\"><span class=\"pre\">MessageChunks</span></tt></li>\n<li>One <tt class=\"docutils literal\"><span class=\"pre\">ChunkedMessageEnd</span></tt></li>\n</ul>\n<p>The timer for checking request timeouts (if configured to non-zero) will stop running as soon as the initial\n<tt class=\"docutils literal\"><span class=\"pre\">ChunkedResponseStart</span></tt> message has been received, i.e. there is currently no timeout checking\nfor and in between individual response chunks.</p>\n</div>\n<div class=\"section\" id=\"http-headers\">\n<h2>HTTP Headers</h2>\n<p>When a <em>spray-can</em> connection actor receives an HTTP response it tries to parse all its headers into their respective\n<em>spray-http</em> model classes. No matter whether this succeeds or not, the connection actor will always pass on all\nreceived headers to the application. Unknown headers as well as ones with invalid syntax (according to <em>spray</em>&#8216;s header\nparser) will be made available as <tt class=\"docutils literal\"><span class=\"pre\">RawHeader</span></tt> instances. For the ones exhibiting parsing errors a warning message is\nlogged depending on the value of the <tt class=\"docutils literal\"><span class=\"pre\">illegal-header-warnings</span></tt> config setting.</p>\n<p>The following message headers are managed by the <em>spray-can</em> layer itself and as such are <strong>ignored</strong> if you &#8220;manually&#8221;\nadd them to an outgoing request:</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Content-Length</span></tt></li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">Transfer-Encoding</span></tt></li>\n</ul>\n<p>There is one exception: for requests with an empty entity <em>spray-can</em> will render manually added <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt>\nheaders.</p>\n<p>Additionally <em>spray-can</em> will render a</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\"><span class=\"pre\">Host</span></tt> request header if none is explicitly added.</li>\n<li><tt class=\"docutils literal\"><span class=\"pre\">User-Agent</span></tt> header if one is configured. If none is configured an explicitly added added <tt class=\"docutils literal\"><span class=\"pre\">User-Agent</span></tt> header is\nalso rendered.</li>\n</ul>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">The <tt class=\"docutils literal\"><span class=\"pre\">Content-Type</span></tt> header has special status in <em>spray</em> since its value is part of the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt> model\nclass. Even though the header also remains in the <tt class=\"docutils literal\"><span class=\"pre\">headers</span></tt> list of the <tt class=\"docutils literal\"><span class=\"pre\">HttpResponse</span></tt> <em>sprays</em> higher layers\n(like <em>spray-client</em>) only work with the <tt class=\"docutils literal\"><span class=\"pre\">ContentType</span></tt> value contained in the <tt class=\"docutils literal\"><span class=\"pre\">HttpEntity</span></tt>.</p>\n</div>\n</div>\n<div class=\"section\" id=\"ssl-support\">\n<h2>SSL Support</h2>\n<p>If enabled via the <tt class=\"docutils literal\"><span class=\"pre\">ssl-encryption</span></tt> config setting the <em>spray-can</em> connection actors pipe all IO traffic through an\n<tt class=\"docutils literal\"><span class=\"pre\">SslTlsSupport</span></tt> module, which can perform transparent SSL/TLS encryption. This module is configured via the implicit\n<tt class=\"docutils literal\"><span class=\"pre\">ClientSSLEngineProvider</span></tt> member on the <tt class=\"docutils literal\"><span class=\"pre\">Http.Connect</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">Http.HostConnectorSetup</span></tt> command messages.\nAn <tt class=\"docutils literal\"><span class=\"pre\">ClientSSLEngineProvider</span></tt> is essentially a function <tt class=\"docutils literal\"><span class=\"pre\">PipelineContext</span> <span class=\"pre\">\u21d2</span> <span class=\"pre\">Option[SSLEngine]</span></tt> which determines\nwhether encryption is to be performed and, if so, which <tt class=\"docutils literal\"><span class=\"pre\">javax.net.ssl.SSLEngine</span></tt> instance is to be used.</p>\n<p>If you&#8217;d like to apply some custom configuration to your <tt class=\"docutils literal\"><span class=\"pre\">SSLEngine</span></tt> instances an easy way would be to bring a custom\nengine provider into scope, e.g. like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">spray.io.ClientSSLEngineProvider</span>\n\n<span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">myEngineProvider</span> <span class=\"k\">=</span> <span class=\"nc\">ClientSSLEngineProvider</span> <span class=\"o\">{</span> <span class=\"n\">engine</span> <span class=\"k\">=&gt;</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledCipherSuites</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS_RSA_WITH_AES_256_CBC_SHA&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">setEnabledProtocols</span><span class=\"o\">(</span><span class=\"nc\">Array</span><span class=\"o\">(</span><span class=\"s\">&quot;SSLv3&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;TLSv1&quot;</span><span class=\"o\">))</span>\n  <span class=\"n\">engine</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>EngineProvider creation also relies on an implicitly available <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt>, which is defined like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">trait</span> <span class=\"nc\">SSLContextProvider</span> <span class=\"k\">extends</span> <span class=\"o\">(</span><span class=\"nc\">PipelineContext</span> <span class=\"k\">\u21d2</span> <span class=\"nc\">Option</span><span class=\"o\">[</span><span class=\"kt\">SSLContext</span><span class=\"o\">])</span>\n</pre></div>\n</div>\n<p>The default <tt class=\"docutils literal\"><span class=\"pre\">SSLContextProvider</span></tt> simply provides an implicitly available &#8220;constant&#8221; <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>, by default the\n<tt class=\"docutils literal\"><span class=\"pre\">SSLContext.getDefault</span></tt> is used. This means that the easiest way to have the server use a custom <tt class=\"docutils literal\"><span class=\"pre\">SSLContext</span></tt>\nis to simply bring one into scope implicitly:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">javax.net.ssl.SSLContext</span>\n\n<span class=\"k\">implicit</span> <span class=\"k\">val</span> <span class=\"n\">mySSLContext</span><span class=\"k\">:</span> <span class=\"kt\">SSLContext</span> <span class=\"o\">=</span> <span class=\"o\">{</span>\n  <span class=\"k\">val</span> <span class=\"n\">context</span> <span class=\"k\">=</span> <span class=\"nc\">SSLContext</span><span class=\"o\">.</span><span class=\"n\">getInstance</span><span class=\"o\">(</span><span class=\"s\">&quot;TLS&quot;</span><span class=\"o\">)</span>\n  <span class=\"c1\">// context.init(...)</span>\n  <span class=\"n\">context</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n</div>\n</div>\n", "display_toc": true, "title": "HTTP Client APIs", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-can/http-client/index", "next": {"link": "connection-level/", "title": "Connection-level API"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-can/http-client/connection-level", "Connection-level API", "N", "next"], ["documentation/spray-can/http-server", "HTTP Server", "P", "previous"]], "meta": {}, "parents": [{"link": "../../", "title": "Documentation"}, {"link": "../", "title": "spray-can"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">HTTP Client APIs</a><ul>\n<li><a class=\"reference internal\" href=\"#basic-api-structure\">Basic API Structure</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-requests\">Chunked Requests</a></li>\n<li><a class=\"reference internal\" href=\"#chunked-responses\">Chunked Responses</a></li>\n<li><a class=\"reference internal\" href=\"#http-headers\">HTTP Headers</a></li>\n<li><a class=\"reference internal\" href=\"#ssl-support\">SSL Support</a></li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../http-server/", "title": "HTTP Server"}, "metatags": ""}