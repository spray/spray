{"body": "<div class=\"section\" id=\"custom-directives\">\n<span id=\"id1\"></span><h1>Custom Directives</h1>\n<p>Part of <em>spray-routings</em> power comes from the ease with which it&#8217;s possible to define custom directives at differing\nlevels of abstraction. There are essentially three ways of creating custom directives:</p>\n<ol class=\"arabic simple\">\n<li>By introducing new &#8220;labels&#8221; for configurations of existing directives</li>\n<li>By transforming existing directives</li>\n<li>By writing a directive &#8220;from scratch&#8221;</li>\n</ol>\n<div class=\"section\" id=\"configuration-labelling\">\n<h2>Configuration Labelling</h2>\n<p>The easiest way to create a custom directive is to simply assign a new name for a certain configuration of one or more\nexisting directives. In fact, most of <em>spray-routings</em> predefined directives can be considered named configurations\nof more low-level directives.</p>\n<p>The basic technique is explained in the chapter about <a class=\"reference internal\" href=\"../../key-concepts/directives/#composing-directives\"><em>Composing Directives</em></a>, where, for example, a new directive\n<tt class=\"docutils literal\"><span class=\"pre\">getOrPut</span></tt> is defined like this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">getOrPut</span> <span class=\"k\">=</span> <span class=\"n\">get</span> <span class=\"o\">|</span> <span class=\"n\">put</span>\n</pre></div>\n</div>\n<p>Another example are the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/release/1.2/spray-routing/src/main/scala/spray/routing/directives/MethodDirectives.scala\">MethodDirectives</a>, which are simply instances of a preconfigured <a class=\"reference internal\" href=\"../../method-directives/method/#method\"><em>method</em></a> directive,\nsuch as:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">val</span> <span class=\"n\">delete</span> <span class=\"k\">=</span> <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"nc\">DELETE</span><span class=\"o\">)</span>\n<span class=\"k\">val</span> <span class=\"n\">get</span> <span class=\"k\">=</span> <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"nc\">GET</span><span class=\"o\">)</span>\n<span class=\"k\">val</span> <span class=\"n\">head</span> <span class=\"k\">=</span> <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"nc\">HEAD</span><span class=\"o\">)</span>\n<span class=\"k\">val</span> <span class=\"n\">options</span> <span class=\"k\">=</span> <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"nc\">OPTIONS</span><span class=\"o\">)</span>\n<span class=\"k\">val</span> <span class=\"n\">patch</span> <span class=\"k\">=</span> <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"nc\">PATCH</span><span class=\"o\">)</span>\n<span class=\"k\">val</span> <span class=\"n\">post</span> <span class=\"k\">=</span> <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"nc\">POST</span><span class=\"o\">)</span>\n<span class=\"k\">val</span> <span class=\"n\">put</span> <span class=\"k\">=</span> <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"nc\">PUT</span><span class=\"o\">)</span>\n</pre></div>\n</div>\n<p>The low-level directives that most often form the basis of higher-level &#8220;named configuration&#8221; directives are grouped\ntogether in the <a class=\"reference internal\" href=\"../../basic-directives/#basicdirectives\"><em>BasicDirectives</em></a> trait.</p>\n</div>\n<div class=\"section\" id=\"transforming-directives\">\n<h2>Transforming Directives</h2>\n<p>The second option for creating new directives is to transform an existing one using one of the &#8220;transformation methods&#8221;,\nwhich are defined on the <a class=\"reference external\" href=\"https://github.com/spray/spray/blob/release/1.2/spray-routing/src/main/scala/spray/routing/Directive.scala\">Directive</a> class, the base class of all &#8220;regular&#8221; directives.</p>\n<p>Apart from the combinator operators (<tt class=\"docutils literal\"><span class=\"pre\">|</span></tt> and <tt class=\"docutils literal\"><span class=\"pre\">&amp;</span></tt>) and the case-class extractor (<tt class=\"docutils literal\"><span class=\"pre\">as[T]</span></tt>) there are these\ntransformations defined on all <tt class=\"docutils literal\"><span class=\"pre\">Directive[L</span> <span class=\"pre\">&lt;:</span> <span class=\"pre\">HList]</span></tt> instances:</p>\n<ul class=\"simple\">\n<li><a class=\"reference internal\" href=\"#map-hmap\">map / hmap</a></li>\n<li><a class=\"reference internal\" href=\"#flatmap-hflatmap\">flatMap / hflatMap</a></li>\n<li><a class=\"reference internal\" href=\"#require-hrequire\">require / hrequire</a></li>\n<li><a class=\"reference internal\" href=\"#recover-recoverpf\">recover / recoverPF</a></li>\n</ul>\n<div class=\"section\" id=\"map-hmap\">\n<h3>map / hmap</h3>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">hmap</span></tt> modifier has this signature (somewhat simplified):</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">hmap</span><span class=\"o\">[</span><span class=\"kt\">R</span><span class=\"o\">](</span><span class=\"n\">f</span><span class=\"k\">:</span> <span class=\"kt\">L</span> <span class=\"o\">=&gt;</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">R</span> <span class=\"kt\">::</span> <span class=\"kt\">HNil</span><span class=\"o\">]</span>\n</pre></div>\n</div>\n<p>It can be used to transform the <tt class=\"docutils literal\"><span class=\"pre\">HList</span></tt> of extractions into another <tt class=\"docutils literal\"><span class=\"pre\">HList</span></tt>. The number and/or types of the\nextractions can be changed arbitrarily. If <tt class=\"docutils literal\"><span class=\"pre\">R</span> <span class=\"pre\">&lt;:</span> <span class=\"pre\">HList</span></tt> then the result is <tt class=\"docutils literal\"><span class=\"pre\">Directive[R]</span></tt>.\nHere is a somewhat contrived example:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">shapeless._</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.routing._</span>\n<span class=\"k\">import</span> <span class=\"nn\">Directives._</span>\n\n<span class=\"k\">val</span> <span class=\"n\">twoIntParameters</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">Int</span> <span class=\"kt\">::</span> <span class=\"kt\">Int</span> <span class=\"kt\">::</span> <span class=\"kt\">HNil</span><span class=\"o\">]</span> <span class=\"k\">=</span>\n  <span class=\"n\">parameters</span><span class=\"o\">(</span><span class=\"-Symbol\">&#39;a</span><span class=\"o\">.</span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"kt\">Int</span><span class=\"o\">],</span> <span class=\"-Symbol\">&#39;b</span><span class=\"o\">.</span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"kt\">Int</span><span class=\"o\">])</span>\n\n<span class=\"k\">val</span> <span class=\"n\">myDirective</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">String</span> <span class=\"kt\">::</span> <span class=\"kt\">HNil</span><span class=\"o\">]</span> <span class=\"k\">=</span>\n  <span class=\"n\">twoIntParameters</span><span class=\"o\">.</span><span class=\"n\">hmap</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"nc\">HNil</span> <span class=\"k\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span><span class=\"o\">).</span><span class=\"n\">toString</span>\n  <span class=\"o\">}</span>\n\n<span class=\"c1\">// test `myDirective` using the testkit DSL</span>\n<span class=\"nc\">Get</span><span class=\"o\">(</span><span class=\"s\">&quot;/?a=2&amp;b=5&quot;</span><span class=\"o\">)</span> <span class=\"o\">~&gt;</span> <span class=\"n\">myDirective</span><span class=\"o\">(</span><span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"k\">_</span><span class=\"o\">))</span> <span class=\"o\">~&gt;</span> <span class=\"n\">check</span> <span class=\"o\">{</span>\n  <span class=\"n\">entityAs</span><span class=\"o\">[</span><span class=\"kt\">String</span><span class=\"o\">]</span> <span class=\"o\">===</span> <span class=\"s\">&quot;7&quot;</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>If the Directive is a single-value Directive, i.e. one that extracts exactly one value, you can also use the simple\n<tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> modifier, which doesn&#8217;t take the directives <tt class=\"docutils literal\"><span class=\"pre\">HList</span></tt> as parameter but rather the single value itself.</p>\n<p>One example of a predefined directive relying on <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> is the <a class=\"reference internal\" href=\"../../header-directives/optionalHeaderValue/#optionalheadervalue\"><em>optionalHeaderValue</em></a> directive.</p>\n</div>\n<div class=\"section\" id=\"flatmap-hflatmap\">\n<h3>flatMap / hflatMap</h3>\n<p>With <tt class=\"docutils literal\"><span class=\"pre\">hmap</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> you can transform the values a directive extracts, but you cannot change the &#8220;extracting&#8221;\nnature of the directive. For example, if you have a directive extracting an <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> you can use <tt class=\"docutils literal\"><span class=\"pre\">map</span></tt> to turn it into\na directive that extracts that <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> and doubles it, but you cannot transform it into a directive, that doubles all\npositive <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> values and rejects all others.</p>\n<p>In order to do the latter you need <tt class=\"docutils literal\"><span class=\"pre\">hflatMap</span></tt> or <tt class=\"docutils literal\"><span class=\"pre\">flatMap</span></tt>. The <tt class=\"docutils literal\"><span class=\"pre\">hflatMap</span></tt> modifier has this signature:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">hflatMap</span><span class=\"o\">[</span><span class=\"kt\">R</span> <span class=\"k\">&lt;:</span> <span class=\"kt\">HList</span><span class=\"o\">](</span><span class=\"n\">f</span><span class=\"k\">:</span> <span class=\"kt\">L</span> <span class=\"o\">=&gt;</span> <span class=\"nc\">Directive</span><span class=\"o\">[</span><span class=\"kt\">R</span><span class=\"o\">])</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">R</span><span class=\"o\">]</span>\n</pre></div>\n</div>\n<p>The given function produces a new directive depending on the <tt class=\"docutils literal\"><span class=\"pre\">HList</span></tt> of extractions of the underlying one.\nAs in the case of <a class=\"reference internal\" href=\"#map-hmap\">map / hmap</a> there is also a single-value variant called <tt class=\"docutils literal\"><span class=\"pre\">flatMap</span></tt>, which simplifies the operation\nfor Directives only extracting one single value.</p>\n<p>Here is the (contrived) example from above, which doubles positive <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> values and rejects all others:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">import</span> <span class=\"nn\">shapeless._</span>\n<span class=\"k\">import</span> <span class=\"nn\">spray.routing._</span>\n<span class=\"k\">import</span> <span class=\"nn\">Directives._</span>\n\n<span class=\"k\">val</span> <span class=\"n\">intParameter</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">Int</span> <span class=\"kt\">::</span> <span class=\"kt\">HNil</span><span class=\"o\">]</span> <span class=\"k\">=</span> <span class=\"n\">parameter</span><span class=\"o\">(</span><span class=\"-Symbol\">&#39;a</span><span class=\"o\">.</span><span class=\"n\">as</span><span class=\"o\">[</span><span class=\"kt\">Int</span><span class=\"o\">])</span>\n\n<span class=\"k\">val</span> <span class=\"n\">myDirective</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">Int</span> <span class=\"kt\">::</span> <span class=\"kt\">HNil</span><span class=\"o\">]</span> <span class=\"k\">=</span>\n  <span class=\"n\">intParameter</span><span class=\"o\">.</span><span class=\"n\">flatMap</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"n\">a</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"k\">=&gt;</span> <span class=\"n\">provide</span><span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"k\">case</span> <span class=\"k\">_</span> <span class=\"k\">=&gt;</span> <span class=\"n\">reject</span>\n  <span class=\"o\">}</span>\n\n<span class=\"c1\">// test `myDirective` using the testkit DSL</span>\n<span class=\"nc\">Get</span><span class=\"o\">(</span><span class=\"s\">&quot;/?a=21&quot;</span><span class=\"o\">)</span> <span class=\"o\">~&gt;</span> <span class=\"n\">myDirective</span><span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"k\">=&gt;</span> <span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">.</span><span class=\"n\">toString</span><span class=\"o\">))</span> <span class=\"o\">~&gt;</span> <span class=\"n\">check</span> <span class=\"o\">{</span>\n  <span class=\"n\">entityAs</span><span class=\"o\">[</span><span class=\"kt\">String</span><span class=\"o\">]</span> <span class=\"o\">===</span> <span class=\"s\">&quot;42&quot;</span>\n<span class=\"o\">}</span>\n<span class=\"nc\">Get</span><span class=\"o\">(</span><span class=\"s\">&quot;/?a=-18&quot;</span><span class=\"o\">)</span> <span class=\"o\">~&gt;</span> <span class=\"n\">myDirective</span><span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"k\">=&gt;</span> <span class=\"n\">complete</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">.</span><span class=\"n\">toString</span><span class=\"o\">))</span> <span class=\"o\">~&gt;</span> <span class=\"n\">check</span> <span class=\"o\">{</span>\n  <span class=\"n\">handled</span> <span class=\"n\">must</span> <span class=\"n\">beFalse</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>A common pattern that relies on <tt class=\"docutils literal\"><span class=\"pre\">flatMap</span></tt> is to first extract a value from the <tt class=\"docutils literal\"><span class=\"pre\">RequestContext</span></tt> with the\n<a class=\"reference internal\" href=\"../../basic-directives/extract/#extract\"><em>extract</em></a> directive and then <tt class=\"docutils literal\"><span class=\"pre\">flatMap</span></tt> with some kind of filtering logic. For example, this is the\nimplementation of the <a class=\"reference internal\" href=\"../../method-directives/method/#method\"><em>method</em></a> directive:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"cm\">/**</span>\n<span class=\"cm\"> * Rejects all requests whose HTTP method does not match the given one.</span>\n<span class=\"cm\"> */</span>\n<span class=\"k\">def</span> <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"n\">mth</span><span class=\"k\">:</span> <span class=\"kt\">HttpMethod</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Directive0</span> <span class=\"o\">=</span>\n  <span class=\"n\">extract</span><span class=\"o\">(</span><span class=\"k\">_</span><span class=\"o\">.</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">method</span><span class=\"o\">).</span><span class=\"n\">flatMap</span><span class=\"o\">[</span><span class=\"kt\">HNil</span><span class=\"o\">]</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"n\">`mth`</span> <span class=\"k\">\u21d2</span> <span class=\"n\">pass</span>\n    <span class=\"k\">case</span> <span class=\"k\">_</span>     <span class=\"k\">\u21d2</span> <span class=\"n\">reject</span><span class=\"o\">(</span><span class=\"nc\">MethodRejection</span><span class=\"o\">(</span><span class=\"n\">mth</span><span class=\"o\">))</span>\n  <span class=\"o\">}</span> <span class=\"o\">&amp;</span> <span class=\"n\">cancelAllRejections</span><span class=\"o\">(</span><span class=\"n\">ofType</span><span class=\"o\">[</span><span class=\"kt\">MethodRejection</span><span class=\"o\">])</span>\n</pre></div>\n</div>\n<p>The explicit type parameter <tt class=\"docutils literal\"><span class=\"pre\">[HNil]</span></tt> on the <tt class=\"docutils literal\"><span class=\"pre\">flatMap</span></tt> is needed in this case because the result of the <tt class=\"docutils literal\"><span class=\"pre\">flatMap</span></tt>\nis directly concatenated with the <a class=\"reference internal\" href=\"../../misc-directives/cancelAllRejections/#cancelallrejections\"><em>cancelAllRejections</em></a> directive, thereby preventing &#8220;outside-in&#8221; inference of\nthe type parameter value.</p>\n</div>\n<div class=\"section\" id=\"require-hrequire\">\n<h3>require / hrequire</h3>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">require</span></tt> modifier transforms a single-extraction directive into a directive without extractions, which filters\nthe requests according the a predicate function. All requests, for which the predicate is <tt class=\"docutils literal\"><span class=\"pre\">false</span></tt> are rejected, all\nothers pass unchanged.</p>\n<p>The signature of <tt class=\"docutils literal\"><span class=\"pre\">require</span></tt> is this (slightly simplified):</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">require</span><span class=\"o\">[</span><span class=\"kt\">T</span><span class=\"o\">](</span><span class=\"n\">predicate</span><span class=\"k\">:</span> <span class=\"kt\">T</span> <span class=\"o\">=&gt;</span> <span class=\"nc\">Boolean</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">HNil</span><span class=\"o\">]</span>\n</pre></div>\n</div>\n<p>One example of a predefined directive relying on <tt class=\"docutils literal\"><span class=\"pre\">require</span></tt> is the first overload of the <a class=\"reference internal\" href=\"../../host-directives/host/#host\"><em>host</em></a> directive.</p>\n<p>You can only call <tt class=\"docutils literal\"><span class=\"pre\">require</span></tt> on single-extraction directives. The <tt class=\"docutils literal\"><span class=\"pre\">hrequire</span></tt> modifier is the more general variant,\nwhich takes a predicate of type <tt class=\"docutils literal\"><span class=\"pre\">HList</span> <span class=\"pre\">=&gt;</span> <span class=\"pre\">Boolean</span></tt>.\nIt can therefore also be used on directives with several extractions.</p>\n</div>\n<div class=\"section\" id=\"recover-recoverpf\">\n<h3>recover / recoverPF</h3>\n<p>The <tt class=\"docutils literal\"><span class=\"pre\">recover</span></tt> modifier allows you &#8220;catch&#8221; rejections produced by the underlying directive and, instead of rejecting,\nproduce an alternative directive with the same type(s) of extractions.</p>\n<p>The signature of <tt class=\"docutils literal\"><span class=\"pre\">recover</span></tt> is this:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">recover</span><span class=\"o\">(</span><span class=\"n\">recovery</span><span class=\"k\">:</span> <span class=\"kt\">List</span><span class=\"o\">[</span><span class=\"kt\">Rejection</span><span class=\"o\">]</span> <span class=\"k\">=&gt;</span> <span class=\"nc\">Directive</span><span class=\"o\">[</span><span class=\"kt\">L</span><span class=\"o\">])</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">L</span><span class=\"o\">]</span>\n</pre></div>\n</div>\n<p>In many cases the very similar <tt class=\"docutils literal\"><span class=\"pre\">recoverPF</span></tt> modifier might be little bit easier to use since it doesn&#8217;t require the\nhandling of <em>all</em> rejections:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">def</span> <span class=\"n\">recoverPF</span><span class=\"o\">(</span><span class=\"n\">recovery</span><span class=\"k\">:</span> <span class=\"kt\">PartialFunction</span><span class=\"o\">[</span><span class=\"kt\">List</span><span class=\"o\">[</span><span class=\"kt\">Rejection</span><span class=\"o\">]</span>, <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">L</span><span class=\"o\">]])</span><span class=\"k\">:</span> <span class=\"kt\">Directive</span><span class=\"o\">[</span><span class=\"kt\">L</span><span class=\"o\">]</span>\n</pre></div>\n</div>\n<p>One example of a predefined directive relying <tt class=\"docutils literal\"><span class=\"pre\">recoverPF</span></tt> is the <a class=\"reference internal\" href=\"../../header-directives/optionalHeaderValue/#optionalheadervalue\"><em>optionalHeaderValue</em></a> directive.</p>\n</div>\n</div>\n<div class=\"section\" id=\"directives-from-scratch\">\n<h2>Directives from Scratch</h2>\n<p>The third option for creating custom directives is to do it &#8220;from scratch&#8221;, by directly subclassing the <tt class=\"docutils literal\"><span class=\"pre\">Directive</span></tt>\nclass. The <tt class=\"docutils literal\"><span class=\"pre\">Directive</span></tt> is defined like this (leaving away operators and modifiers):</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">abstract</span> <span class=\"k\">class</span> <span class=\"nc\">Directive</span><span class=\"o\">[</span><span class=\"kt\">L</span> <span class=\"k\">&lt;:</span> <span class=\"kt\">HList</span><span class=\"o\">]</span> <span class=\"o\">{</span>\n  <span class=\"k\">def</span> <span class=\"n\">happly</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"k\">:</span> <span class=\"kt\">L</span> <span class=\"o\">=&gt;</span> <span class=\"nc\">Route</span><span class=\"o\">)</span><span class=\"k\">:</span> <span class=\"kt\">Route</span>\n<span class=\"o\">}</span>\n</pre></div>\n</div>\n<p>It only has one abstract member that you need to implement, the <tt class=\"docutils literal\"><span class=\"pre\">happly</span></tt> method, which creates the <tt class=\"docutils literal\"><span class=\"pre\">Route</span></tt>, the\ndirectives presents to the outside, from its inner Route building function (taking the extractions as parameter).</p>\n<p>Extractions are kept as a <a class=\"reference external\" href=\"https://github.com/milessabin/shapeless\">shapeless</a> <tt class=\"docutils literal\"><span class=\"pre\">HList</span></tt>. Here are a few examples:</p>\n<ul class=\"wide\">\n<li><p class=\"first\">A <tt class=\"docutils literal\"><span class=\"pre\">Directive[HNil]</span></tt> extracts nothing (like the <tt class=\"docutils literal\"><span class=\"pre\">get</span></tt> directive). Because this type is used quite frequently\n<em>spray-routing</em> defines a type alias for it:</p>\n<div class=\"highlight-scala\"><div class=\"highlight\"><pre><span class=\"k\">type</span> <span class=\"kt\">Directive0</span> <span class=\"o\">=</span> <span class=\"nc\">Directive</span><span class=\"o\">[</span><span class=\"kt\">HNil</span><span class=\"o\">]</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"first\">A <tt class=\"docutils literal\"><span class=\"pre\">Directive[String</span> <span class=\"pre\">::</span> <span class=\"pre\">HNil]</span></tt> extracts one <tt class=\"docutils literal\"><span class=\"pre\">String</span></tt> value (like the <a class=\"reference internal\" href=\"../../host-directives/hostName/#hostname\"><em>hostName</em></a> directive).</p>\n</li>\n<li><p class=\"first\">A <tt class=\"docutils literal\"><span class=\"pre\">Directive[Int</span> <span class=\"pre\">::</span> <span class=\"pre\">String</span> <span class=\"pre\">::</span> <span class=\"pre\">HNil]</span></tt> extracts an <tt class=\"docutils literal\"><span class=\"pre\">Int</span></tt> value and a <tt class=\"docutils literal\"><span class=\"pre\">String</span></tt> value\n(like a <tt class=\"docutils literal\"><span class=\"pre\">parameters('a.as[Int],</span> <span class=\"pre\">'b.as[String]</span></tt> directive).</p>\n</li>\n</ul>\n<p>Keeping extractions as <em>HLists</em> has a lot of advantages, mainly great flexibility while upholding full type safety and\n&#8220;inferability&#8221;. However, the number of times where you&#8217;ll really have to fall back to defining a directive from scratch\nshould be very small. In fact, if you find yourself in a position where a &#8220;from scratch&#8221; directive is your only option,\nwe&#8217;d like to hear about it, so we can provide a higher-level &#8220;something&#8221; for other users.</p>\n</div>\n</div>\n", "display_toc": true, "title": "Custom Directives", "sourcename": "", "customsidebar": null, "current_page_name": "documentation/spray-routing/advanced-topics/custom-directives", "next": {"link": "../response-streaming/", "title": "Response Streaming"}, "rellinks": [["genindex", "General Index", "I", "index"], ["documentation/spray-routing/advanced-topics/response-streaming", "Response Streaming", "N", "next"], ["documentation/spray-routing/advanced-topics/case-class-extraction", "Case Class Extraction", "P", "previous"]], "meta": {}, "parents": [{"link": "../../../", "title": "Documentation"}, {"link": "../../", "title": "spray-routing"}, {"link": "../", "title": "Advanced Topics"}], "sidebars": null, "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Custom Directives</a><ul>\n<li><a class=\"reference internal\" href=\"#configuration-labelling\">Configuration Labelling</a></li>\n<li><a class=\"reference internal\" href=\"#transforming-directives\">Transforming Directives</a><ul>\n<li><a class=\"reference internal\" href=\"#map-hmap\">map / hmap</a></li>\n<li><a class=\"reference internal\" href=\"#flatmap-hflatmap\">flatMap / hflatMap</a></li>\n<li><a class=\"reference internal\" href=\"#require-hrequire\">require / hrequire</a></li>\n<li><a class=\"reference internal\" href=\"#recover-recoverpf\">recover / recoverPF</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#directives-from-scratch\">Directives from Scratch</a></li>\n</ul>\n</li>\n</ul>\n", "prev": {"link": "../case-class-extraction/", "title": "Case Class Extraction"}, "metatags": ""}